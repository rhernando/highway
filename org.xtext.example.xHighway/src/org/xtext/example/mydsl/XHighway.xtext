// automatically generated by Xtext
grammar org.xtext.example.mydsl.XHighway with org.eclipse.xtext.common.Terminals

import "platform:/resource/Highway/model/highway.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Highway returns Highway:
	{Highway}
	'Highway'
	'{'
		('initNodes' '{' initNodes+=Node ( "," initNodes+=Node)* '}' )?
		('initCars' '{' initCars+=Car ( "," initCars+=Car)* '}' )?
		('initSegments' '{' initSegments+=Segment ( "," initSegments+=Segment)* '}' )?
		('initSemaphore' '{' initSemaphore+=Semaphore ( "," initSemaphore+=Semaphore)* '}' )?
		('initSignal' '{' initSignal+=Signal ( "," initSignal+=Signal)* '}' )?
	'}';

Node returns Node:
	Node_Impl | Extractor | Injector;

Signal returns Signal:
	Signal_Impl | Speedlimit | Stop | Yield;

Node_Impl returns Node:
	{Node}
	'Node'
	'{'
		'hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')'
		'hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')'
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

Car returns Car:
	{Car}
	'Car'
	'{'
		('timeIn' timeIn=EDate)?
		('timeOut' timeOut=EDate)?
		('isInSegment' isInSegment=[Segment|EString])?
	'}';

Segment returns Segment:
	{Segment}
	'Segment'
	'{'
		('numLanes' numLanes=EInt)?
		('length' length=EInt)?
		('hasCars' '(' hasCars+=[Car|EString] ( "," hasCars+=[Car|EString])* ')' )?
	'}';

Semaphore returns Semaphore:
	'Semaphore'
	'{'
	    ('canGo' canGo=EBoolean)?
		('secondsRed' secondsRed=EInt)?
		('secondsGreen' secondsGreen=EInt)?
		'belongsTo' belongsTo=[Node|EString]
	'}';

Signal_Impl returns Signal:
	'Signal'
	'{'
		'belongsTo' belongsTo=[Node|EString]
	'}';

Extractor returns Extractor:
	{Extractor}
	'Extractor'
	'{'
		('hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')' )?
		'hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')'
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

Injector returns Injector:
	{Injector}
	'Injector'
	'{'
		('carsPerHour' carsPerHour=EInt)?
		'hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')'
		('hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')' )?
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

EInt returns ecore::EInt:
	'-'? INT;

EDate returns ecore::EDate:
	STRING;
	//'EDate' /* TODO: implement this rule and an appropriate IValueConverter */;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

Speedlimit returns Speedlimit:
	'Speedlimit'
	'{'
		('Speed' Speed=EInt)?
		'belongsTo' belongsTo=[Node|EString]
	'}';

Stop returns Stop:
	'Stop'
	'{'
		'belongsTo' belongsTo=[Node|EString]
	'}';

Yield returns Yield:
	'Yield'
	'{'
		'belongsTo' belongsTo=[Node|EString]
	'}';

EString returns ecore::EString:
	STRING | ID;
