// automatically generated by Xtext
grammar org.xtext.Highway with org.eclipse.xtext.common.Terminals

import "platform:/resource/Highway/model/highway.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Highway returns highway: {highway}
	'Highway'
	'{'
		('Segments' '{' initSegments+=Segment ( "," initSegments+=Segment)* '}' )?
		('Nodes' '{' initNodes+=Node ( "," initNodes+=Node)* '}' )?
		('Cars' '{' initCars+=Car ( "," initCars+=Car)* '}' )?
		('Semaphores' '{' initSemaphore+=Semaphore ( "," initSemaphore+=Semaphore)* '}' )?
		('Signals' '{' initSignal+=Signal ( "," initSignal+=Signal)* '}' )?
	'}';

Node returns Node:
	Node_Impl | Extractor | Injector;

Signal returns Signal:
	Signal_Impl | Speedlimit | Stop | Yield;

Node_Impl returns Node: {Node}
	'Node' name=EString '{'
		'hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')'
		'hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')'
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

Car returns Car: {Car}
	'Car' name=EString '{'
		('timeIn' timeIn=EDate)?
		('timeOut' timeOut=EDate)?
		('isInSegment' isInSegment=[Segment|EString])?
	'}';

Segment returns Segment: {Segment}
	'Segment' name=EString '{'
		('numLanes' numLanes=EInt)?
		('length' length=EInt)?
		('hasCars' '(' hasCars+=[Car|EString] ( "," hasCars+=[Car|EString])* ')' )?
	'}';

Semaphore returns Semaphore: {Semaphore}
	'Semaphore' name=EString '{'
	    ('canGo' canGo=EBoolean)?
		('secondsRed' secondsRed=EInt)?
		('secondsGreen' secondsGreen=EInt)?
		'belongsTo' belongsTo=[Node|EString]
	'}';

Signal_Impl returns Signal: {Signal}
	'Signal' name=EString '{'
		'belongsTo' belongsTo=[Node|EString]
	'}';

EString returns ecore::EString:
	STRING | ID;

Extractor returns Extractor: {Extractor}
	'Extractor' name=EString '{'
		('hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')' )?
		'hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')'
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

Injector returns Injector: {Injector}
	'Injector' name=EString '{'
		('carsPerHour' carsPerHour=EInt)?
		'hasStarts' '(' hasStarts+=[Segment|EString] ( "," hasStarts+=[Segment|EString])* ')'
		('hasEnds' '(' hasEnds+=[Segment|EString] ( "," hasEnds+=[Segment|EString])* ')' )?
		('semaphore' semaphore=[Semaphore|EString])?
		('signals' '(' signals+=[Signal|EString] ( "," signals+=[Signal|EString])* ')' )?
	'}';

EInt returns ecore::EInt:
	'-'? INT;

EDate returns ecore::EDate:
	STRING /* TODO: implement this rule and an appropriate IValueConverter */;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

Speedlimit returns Speedlimit:
	'Speedlimit' name=EString
	'{'
		('Speed' Speed=EInt)?
		'belongsTo' belongsTo=[Node|EString]
	'}';

Stop returns Stop:
	'Stop' name=EString
	'{'
		'belongsTo' belongsTo=[Node|EString]
	'}';

Yield returns Yield:
	'Yield' name=EString
	'{'
		'belongsTo' belongsTo=[Node|EString]
	'}';
